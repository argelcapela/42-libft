<!--<div id="portfolio-slideshow-items" class="hide-on-portfolio" visibility="0">
    
</div>
-->

<div class="hide-on-portfolio">

<div align="center" id="topo">
	<p><i>"Nunca perca a esperan√ßa na humanidade, porque ela √© como um oceano. S√≥ porque existem algumas gotas de √°gua suja nele, n√£o quer dizer que esteja sujo por completo."</i><br><b>Mahatma Gandhi</b></p>
<br><br>
	<img src="https://github.com/argelcapela/argelcapela.rf.gd/blob/main/assets/img/galeria/portfolio_img_42-libft.jpg?raw=true" width="250px">
</div>
<br><br>
	
# :sparkles: O que √© a 42-libft ?
<b>Esse projeto visa construir do zero uma biblioteca de fun√ß√µes fundamentais para trabalhar com a linguagem C. Por exemplo: substring(), trim(), strdup() etc. Um excelente exerc√≠cio de l√≥gica, Makefile e constru√ß√£o de bibliotecas.</b><br>

</div>

<div class="col-12">

# :wrench: Tecnologias utilizadas:<br>
<div style="display: inline_block">
    <img align="center" alt="gel-Js" height="30" width="40" src="https://raw.githubusercontent.com/devicons/devicon/master/icons/c/c-original.svg">

</div>

<div class="col-12">

# :rocket: Rodando o projeto:<br>
<b>Links:</b>
<li>Reposit√≥rio Github: <a href="https://github.com/argelcapela/42-libft">Link</a></li>
<li>Intra 42SP: <a href="https://projects.intra.42.fr/projects/42cursus-libft">Link</a></li>
<br><br>

<div class="col-12">
    
# :pushpin: O que eu aprendi e como foi desenvolvido esse projeto?<br>
<b>1) Conhecimento adquiridos para construir a libft</b><br>
<li><a href="#entendendo">Entendendo melhor a Libft!</a></li>
<ol>
<i>Mandat√≥rio:</i>
	<li><a href="#ft_split">ft_split</a></li>
	<li><a href="#ft_strtrim">ft_strtrim</a></li>
	<li><a href="#ft_atoi">ft_atoi</a></li>
	<li><a href="#ft_itoa">ft_itoa</a></li>
	<li><a href="#ft_strnstr">ft_strnstr</a></li>
	<li><a href="#ft_strncmp">ft_strncmp</a></li>
	<li><a href="#ft_memcmp">ft_memcmp</a></li>
	<li><a href="#ft_substr">ft_substr</a></li>
	<li><a href="#ft_join">ft_join</a></li>
	<li><a href="#ft_strlcat">ft_strlcat</a></li>
	<li><a href="#ft_putnbr_fd">ft_putnbr_fd</a></li>
	<li><a href="#ft_strmapi">ft_strmapi</a></li>
	<li><a href="#ft_striteri">ft_striteri</a></li>
	<li><a href="#ft_strlcpy">ft_strlcpy</a></li>
	<li><a href="#ft_memcpy">memcpy</a></li>
	<li><a href="#ft_memmove">ft_memmove</a></li>
	<li><a href="#ft_strchr">ft_strchr</a></li>
	<li><a href="#ft_strrchr">ft_strrchr</a></li>
	<li><a href="#ft_memchr">ft_memchr</a></li>
	<li><a href="#ft_strdup">ft_strdup</a></li>
	<li><a href="#ft_calloc">ft_calloc</a></li>
	<li><a href="#ft_memset">ft_memset</a></li>
	<li><a href="#ft_bzero">ft_bzero</a></li>
	<li><a href="#ft_isalpha">ft_isalpha</a></li>
	<li><a href="#ft_isdigit">ft_isdigit</a></li>
	<li><a href="#ft_isalnum">ft_isalnum</a></li>
	<li><a href="#ft_isascii">ft_isascii</a></li>
	<li><a href="#ft_isprint">ft_isprint</a></li>
	<li><a href="#ft_strlen">ft_strlen</a></li>
	<li><a href="#ft_toupper">ft_toupper</a></li>
	<li><a href="#ft_tolower">ft_tolower</a></li>
	<li><a href="#ft_putstr_fd">ft_putstr_fd</a></li>
	<li><a href="#ft_putendl_fd">ft_putendl_fd</a></li>
	<li><a href="#ft_putchar_fd">ft_putchar_fd</a></li>
<i>B√¥nus:</i>
	<li><a href="#ft_lstnew">ft_lstnew</a></li>
	<li><a href="#ft_lstadd_front">ft_lstadd_front</a></li>
	<li><a href="#ft_lstsize">ft_lstsize</a></li>
	<li><a href="#ft_lstlast">ft_lstlast</a></li>
	<li><a href="#ft_lstadd_back">ft_lstadd_back</a></li>
	<li><a href="#ft_lstdelone">ft_lstdelone</a></li>
	<li><a href="#ft_lstclear">ft_lstclear</a></li>
	<li><a href="#ft_lstiter">ft_lstiter</a></li>
	<li><a href="#ft_lstmap">ft_lstmap</a></li>
</ol>
<li><a href="#makefile">Partiu dominar o 'Makefile'?</a></li>
<li><a href="#biblioteca">Que parada √© essa de bibliotecas em C?</a></li>
<li><a href="#restrict">O que √© 'restrict' antes das vari√°veis? √© de comer?</a></li>
<br>
	
<b>2) Brinde</b>
<li><a href="#step-by-step"> 42-libft Passo a Passo</a></li>
<li><a href="#outras">Outras Coisas Legais</a></li>
<li><a href="#fontes">Fontes</a></li>
</div>
<br>	
	
<div class="col-12">
	
# :handshake: Colaboradores:<br>
<table>
  <tr>
    <td align="center">
      <a href="http://github.com/argelcapela">
        <img src="https://avatars.githubusercontent.com/u/79276276?s=400&u=055b803f4708d59eaf50208ba601f85844125757&v=4" width="100px;" alt="Foto de Argel Capela!"/><br>
        <sub>
          <b>Argel Capela</b>
        </sub>
      </a>
    </td>
  </tr>
</table>
<br><br>
</div>
	
<div class="col-12">
	
# :dart: Status do projeto:<br>
<img src="https://github.com/argelcapela/argelcapela.rf.gd/blob/main/assets/icons/finalizado.png?raw=true" width="250px" height="200px">
</div>
	
<br>

<div class="col-12">
	
# :clipboard: Nota:<br>
<img src="https://github.com/argelcapela/42-trilha-de-fundamentos/blob/main/assets/nota-125.png?raw=true" width="150px" height="150px" alt="nota libft">
</div>
	
<br>

<div class="col-12">
	
# :bug:	 Erros:<br>
<p>Identificou um erro? Por favor me informe! ou fique a vontade para criar um *issue* aqui no Github e contribuir.</p>
<p>Tamb√©m fique a vontade para opinar, criticar, xingar, elogiar etc. Para mim √© tudo a mesma coisa, fonte de crescimento pessoal. Eu n√£o sei tudo, mas estou buscando ser um profissional 1% melhor a cada dia.</p>
</div>
	
<div class="col-12">
<p>N√£o esque√ßa de dar um ‚≠êÔ∏è se voc√™ gostou, ou se esse reposit√≥rio te ajudou de alguma maneira, isso ir√° me ajudar muito! Obrigado, voc√™ √© top! üòÅüëç</p>
</div>
	

	
	
	
<br><br><br>
<br><br><br>
<br><br>
	
<div align="center">

# :crown: 
	
</div>    
<br><br>


<br><br>
<img src="https://github.com/argelcapela/argelcapela.rf.gd/blob/main/assets/icons/desenvolvimento.png?raw=true" width="250px" height="200px">
<h2 id="entendendo">Entendendo a Libft!</h2>
<b>Primeiramente... quantos fun√ß√µes existem no libft?</b>
<p>S√£o 45 fun√ß√µes no total. 36 Mandat√≥rias e 9 B√¥nus.</p>
	
<b>Vamos ver uma por uma?</b><br>	
S√≥ se for agora truta! üòéüëå<br>
<i>*N.O. Libc: S√£o fun√ß√µes que n√£o s√£o oficiais das bibliotecas padr√µes do C, mas sim, derivadas.</i><br>
<i>*As fun√ß√µes est√£o ordenadas em ordem de complexidade de implementa√ß√£o e de entendimento pr√°tico, na minha opini√£o! üòÅ‚úî. Vc n√£o √© obrigado a concordar!</i><br>
<br><br>
<!--# 4 ft_split-->
<table id="ft_split">
<thead>
	<tr>
		<th colspan="4">ft_split</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e retorna um array de strings obtido a partir da divis√£o de s, usando o caracter 'c' como delimitador.</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_split.c">char **ft_split(char const *s, char c);</a></td>
		<td>
			<ul>
				<li>Matriz de strings</li>
				<li>Nulo se a aloca√ß√£o de mem√≥ria falhar</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
	
<!--# 5 ft_strtrim-->
<table id="ft_strtrim">
<thead>
	<tr>
		<th colspan="4">ft_strtrim</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e retorna uma c√≥pia de 's1' com cada caracter de 'set' removido do come√ßo e do fim de uma string.</td>
		<td>stdlib.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strtrim.c">char *ft_strtrim(char const *s1, char const *set);</a></td>
		<td>
			<ul>
				<li>String aparada, ou seja, com os caracteres cortados do come√ßo e do fim, se houver correspond√™ncia √© claro!</li>
				<li>Nulo se a aloca√ß√£o de mem√≥ria falhar</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>

<!--# 2 atoi	-->
<table id="ft_atoi">
<thead>
	<tr>
		<th colspan="4"><a href="https://man7.org/linux/man-pages/man3/atoi.3.html">ft_atoi</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Converte de String para Inteiro</td>
		<td>stdlib.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_atoi.c">int atoi(const char *nptr);</a></td>
		<td>
			<ul>
				<li>O Valor convertido</li>
				<li>0 em caso de erro</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
	
<!--# 3 itoa	-->
<table id="ft_itoa">
<thead>
	<tr>
		<th colspan="4">ft_itoa</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e retorna uma string representando o inteiro recebido como argumento</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_itoa.c">char *ft_itoa(int n);</a></td>
		<td>
			<ul>
				<li>A String representando o inteiro.</li>
				<li>NULL se a aloca√ß√£o falhar</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--# 1 strnstr
 -->
<table id="ft_strnstr">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=strnstr&sektion=3">ft_strnstr</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Retorna a primeira ocorr√™ncia de little dentro de big</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strnstr.c">char *strstr(const char *big, const char	*little);</a></td>
		<td>
			<ul>
				<li>Se little √© uma string vazia, retorna big</li>
				<li>Se little n√£o existe na string, retorna NULL</li>
				<li>Se little √© encontrado, um ponteiro para a primeira ocorr√™ncia de little dentro de big √© retornado.</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--# 6 ft_memcmp-->
<table id="ft_strncmp">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=strncmp&apropos=0&sektion=3&manpath=FreeBSD+13.0-RELEASE&arch=default&format=html">ft_strncmp</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Percorrer os primeiros 'n' bytes dos blocos de mem√≥ria 's1' e 's2' paralelamente, e retornar a diferen√ßa entre o valor ASCII de ambos. Com isso, podemos saber se duas strings s√£o iguais ou n√£o.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strncmp.c">int strcmp(const char *s1, const char *s2);</a></td>
		<td>
			<ul>
				<li>N√∫mero < 0 -> Se o "valor ASCII de algum caracter de 's1'" for menor que o "valor ASCII de outro caracter em 's2'" </li>
				<li>N√∫mero > 0 -> Se o "valor ASCII de algum caracter de 's1'" for maior que o "valor ASCII de outro caracter em 's2'" </li>
				<li>N√∫mero = 0 -> Se n√£o houver diferen√ßa entre os "valores ASCII 's1'" e os "valores ASCII de 's2'" </li>
				<li>Se 'n' √© zero, o valor de retorno √© zero</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
	
<!--# 6 ft_memcmp-->
<table id="ft_memcmp">
<thead>
	<tr>
		<th colspan="4"><a href="https://man7.org/linux/man-pages/man3/memcmp.3.html">ft_memcmp</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Percorrer os primeiros 'n' bytes dos blocos de mem√≥ria 's1' e 's2' paralelamente, e retornar a diferen√ßa entre o valor ASCII de ambos. Com isso, podemos saber se duas strings s√£o iguais ou n√£o.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_memcmp.c">int memcmp(const void *s1, const void *s2, size_t n);</a></td>
		<td>
			<ul>
				<li>N√∫mero < 0 -> Se o "valor ASCII de algum caracter de 's1'" for menor que o "valor ASCII de outro caracter em 's2'" </li>
				<li>N√∫mero > 0 -> Se o "valor ASCII de algum caracter de 's1'" for maior que o "valor ASCII de outro caracter em 's2'" </li>
				<li>N√∫mero = 0 -> Se n√£o houver diferen√ßa entre os "valores ASCII 's1'" e os "valores ASCII de 's2'" </li>
				<li>Se 'n' √© zero, o valor de retorno √© zero</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--# 7 ft_substr-->
<table id="ft_substr">
<thead>
	<tr>
		<th colspan="4">ft_substr</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e retorna a string 's' aparada, come√ßando na posi√ß√£o 'start' e caminhando 'len' para frente. como assim ? A string retornada √© uma "substring", ou seja, uma string contida dentro de outra string. Por exemplo: 'argelcapela', se meu start √© 0, e meu len √© 5, o retorno √© 'argel' somente, ou seja, a string foi aparada, cortada, ou foi retornado um substring dessa string.</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_substr.c">char *ft_substr(char const *s, unsigned int start,
size_t len);</a></td>
		<td>
			<ul>
				<li>Substring de 's'</li>
				<li>NULL se a aloca√ß√£o de mem√≥ria falhar</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--# 8 ft_strjoin-->
<table id="ft_strjoin">
<thead>
	<tr>
		<th colspan="4">ft_strjoin</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aloca mem√≥ria e retorna uma nova string, que √© o resultado da concatena√ß√£o ('jun√ß√£o') das strings 's1' e 's2'</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strjoin.c">char *ft_strjoin(char const *s1, char const *s2);</a></td>
		<td>
			<ul>
				<li>String nova concatena√ß√£o de 's1' e 's2'</li>
				<li>NULL se a aloca√ß√£o falhar.</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--# 9 ft_putnbr_fd-->
<table id="ft_putnbr_fd">
<thead>
	<tr>
		<th colspan="4">ft_putnbr_fd</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Printa um n√∫mero inteiro 'n' em um File Descriptor.</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_putbnr_fd.c">void ft_putnbr_fd(int n, int fd);</a></td>
		<td>
			<ul>
				<li>Nada</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--# 10 ft_strmapi-->
<table id="ft_strmapi">
<thead>
	<tr>
		<th colspan="4">ft_strmapi</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aplica a fun√ß√£o 'f' para cada caractere da string 's', resultando na cria√ß√£o de uma nova string modificada.</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strmapi.c">char *ft_strmapi(char const *s, char (*f)(unsigned
int, char));</a></td>
		<td>
			<ul>
				<li>A string criada pela sucessiva aplica√ß√£o de 'f'</li>
				<li>NULL se a aloca√ß√£o falhar</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--# 11 ft_striteri-->
<table id="ft_striteri">
<thead>
	<tr>
		<th colspan="4">ft_striteri</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Aplica a fun√ß√£o 'f' em cada caractere da string 's'.</td>
		<td>N.O. Libc</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_striteri.c">void ft_striteri(char *s, void (*f)(unsigned int,
char*));</a></td>
		<td>
			<ul>
				<li>Nada</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--# 12 ft_strlcpy-->
<table id="ft_strlcpy">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=strlcpy&sektion=3">ft_strlcpy</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Copia os primeiros 'size' caracteres da string 'src' para 'dst'.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strlcpy.c">size_t
     strlcpy(char * restrict dst, const	char * restrict	src, size_t dstsize);</a></td>
		<td>
			<ul>
				<li>Retorna o tamanho total de src.</li>
				<li>Se o valor de retorno for >= 'dstsize' a string de sa√≠da foi "TRUNCADA", ou seja, est√° cortada, inacabada ou imcompleta.</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--#  ft_memcpy-->
<table id="ft_memcpy">
<thead>
	<tr>
		<th colspan="4"><a href="https://man7.org/linux/man-pages/man3/memcpy.3.html">ft_memcpy</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Copia n bytes do bloco de mem√≥ria 'src' para o bloco de mem√≥ria 'dest'.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_memcpy.c">void *memcpy(void *restrict dest, const void *restrict src, size_t n);</a></td>
		<td>
			<ul>
				<li>Ponteiro para 'dest'</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--#  ft_memmove -->
<table id="ft_memmove">
<thead>
	<tr>
		<th colspan="4">ft_memmove</th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Copia n bytes de um bloco de mem√≥ria 'src' para outro bloco de mem√≥ria 'dest'.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_memmove.c">void *memmove(void *dest, const void *src, size_t n);</a></td>
		<td>
			<ul>
				<li>Retorna um ponteiro para 'dest'</li>
				<li><i>A diferen√ßa entre os dois √© que no memcpy voc√™ tem que garantir que 'src' e 'dest' s√£o diferentes, ou pode gerar comportamento inesperado, por causa do restrict;</i></li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--# ft_strrchr -->
<table id="ft_strrchr">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=strrchr&sektion=3&apropos=0&manpath=freebsd">ft_strrchr</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Localiza a primeira ocorr√™ncia de 'c' dentro de 's'.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strrchr.c">char *strrchr(const char	*s, int	c);</a></td>
		<td>
			<ul>
				<li>Retorna um ponteiro para o primeiro 'c' localizado em 's'</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>
<!--# ft_strrrchr -->
<table id="ft_strrchr">
<thead>
	<tr>
		<th colspan="4"><a href="https://www.freebsd.org/cgi/man.cgi?query=strrchr&sektion=3&apropos=0&manpath=freebsd">ft_strrrchr</a></th>
	</tr>
	<tr>
		<th>O que ela faz?</th>
		<th>Lib Origem</th>
		<th>Prot√≥tipo</th>
		<th>Valores de Retorno</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>Localiza a √∫ltima ocorr√™ncia de 'c' dentro de 's'.</td>
		<td>string.h</td>
		<td><a href="https://github.com/argelcapela/42-libft/blob/main/src/ft_strrchr.c">char *strrchr(const char	*s, int	c);</a></td>
		<td>
			<ul>
				<li>Retorna um ponteiro para o √∫ltimo 'c' localizado em 's'</li>
			</ul>
		</td>
	</tr>
</tbody>	
</table>
<br>
	
Exemplo:
	
```

```	
	
Sa√≠da:
	
```

```
	
<br><br>



	
	
	
	
	
	
<!--
<b>Passos Ess√™ncias para se construir uma GNL</b>
	<br>
	<ol>
<br>
<i>Mandat√≥rio:</i>
		<li>Ler BUFFER_SIZE caracteres usando a read() quantas vezes forem necess√°rio</li>
		<li>Eu devo usar malloc no meu buffer(fun√ß√£o read) ou usar um array de tamanho fixo?</li>
		<li>Encontrar o '\n'</li>
		<li>Retornar o texto lido antes do \n</li>
		<li>Guardar o texto lido depois do \n, caso haja</li>
		<li>Utilizar o texto guardado na chamada anterior da GNL</li>
		<li>Em quais casos a minha GNL deve retornar NULL?</li>
		<br>
<i>B√¥nus:</i>
		<li>Quantos FILE DESCRIPTOR poss√≠veis um sistema pode ter de uma vez?</li>
		<li>Como a vari√°vel est√°tica pode persistir a posi√ß√£o de um FD sem interferir a de outro?</li>
		<li>üòàComo dar FREE em todas as fun√ß√µes que usam MALLOC e eliminar os leaks de mem√≥ria?üòà</li>
	</ol>
<small>Adaptado de uma <a href="https://discord.com/channels/@me/895737928469340160/895737932240023622">thread</a> no slack da 42 mundial</small>
<br><br>
<b>Essa foi a minha l√≥gica para construir a GNL, tendo como base os pontos acima:</b>
<p>N√£o √© a melhor de todas, mas foi a maneira que eu desenvolvi. #SempreAprendendo! üòÅ‚úå</p>
<img src="https://github.com/argelcapela/42-trilha-de-fundamentos/blob/main/assets/42-get-next-line/fluxograma.jpg?raw=true" alt="Algoritmo GNL!"> 
<a href="https://miro.com/app/board/uXjVOXd2zpY=/?invite_link_id=153572408505">Clique aqui para uma melhor visualiza√ß√£o</a>
<br><br>
-->

<a href="https://www.gnu.org/software/make/manual/make.html"><h2 id="makefile">Partiu dominar o 'Makefile'?</h2></a>
<br>
<b>O que √© Makefile?</b>
<p>Arquivo que cont√©m v√°rios comandos Shell organizados para serem executados automaticamente, toda vez que voc√™ da o comando make. Em poucas palavras, um automatizador de comandos. O objetivo primordial do Makefile segundo muitos portais √© automatizar comandos para: primeiro compilar arquivos de c√≥digo fonte (.c) transformando-os em arquivo objeto, segundo, realizar a "linkedi√ß√£o", transformando esses arquivos objeto (.o) em arquivos bin√°rios, execut√°veis. (.exe/.out/.elf/etc). Ent√£o √© isso, o Makefile serve para, depois que a gente organiza ele bonitinho, ele faz todo o trabalho pra gente sempre que precisar-mos.</p>
<br>
<br>
<b>Que mais?</b>
<br><br>
<img src="" alt="compilation and linker">
<br><br>
	
```
# sintax das diretivas de um makefile comum
	
alvo: pr√©-requisito
<tab> receita	
```
<br><br>
	
```
# alvo: 
# - Nome da a√ß√£o a ser executada
# - Mais comum colocar o nome do arquivo a ser gerado;
	
# pr√©-requisito: 
# - Outros alvos, que ser√£o executados, ou criados, antes de executar esse alvo em quest√£o, geralmente os pr√©-requisitos vem depois e n√£o antes, √© como se o Makefile fosse escrito de tr√°s para frente, do √∫ltimo arquivo a ser gerado para o primeiro. (Estranho n√©, mas √© o que eu vejo por ai.. S√≥ aceita.. üôÑüòõ)
# - Arquivos que s√£o necess√°rios para gerar o nosso "alvo";	

# receita: 
# - Comandos SHELL eeeee, f√°cil.
# - Comandos para executar a a√ß√£o que nosso alvo deseja, ou gerar um arquivo desejado.

```
	
<br><br>
<b>Exemplo de Makefile simples para compilar um programinha simples de Hellowolrd:</b>
<br>
<i>hellowolrd.h</i>	
	
```
#ifndef HELLO_WOLRD_H
#define HELLO_WOLRD_H

#include <stdio.h>
#include <string.h>

char *hello_wolrd();

#endif
```
	
<br><br><br>
<i>hellowolrd.c</i>
	
```
#include "hellowolrd.h"

char *hello_wolrd()
{
	return (strdup("Hello Wolrd!"));
}
```	
	
<br><br><br>
<i>hellowolrd.c</i>
	
```
#include "hellowolrd.h"

char *hello_wolrd()
{
	return (strdup("Hello Wolrd!"));
}
```	
	
<br><br><br>
<i>main.c</i>
	
```
#include "hellowolrd.h"

int main(void)
{
	char *resposta = hello_wolrd();
	printf("%s", resposta);
	return (0);
}

```	
	
<br><br><br>
<i>Makefile</i>
	
```
all: hellowolrd

hellowolrd: main.o hellowolrd.o
	gcc -o hellowolrd main.o hellowolrd.o hellowolrd.h

# arquivo.h n√£o √© obrigat√≥rio mas..
# se n√£o √© colocado no gcc final, √© gerado um arquivo chato (.h.gch)

main.o:
	gcc -o main.o -c main.c

hellowolrd.o:
	gcc -o hellowolrd.o -c hellowolrd.c

clean:
	rm -f *.out *.o *.gch

```	
<br>
<ol>
	<li>Quando executamos o comando make, makefile automaticamente busca o alvo all, sempre.</li>
	<li>O alvo all, quer ser executado e verifica se tem algum pr√©-requisito, ele precisa de um arquivo, ou alvo chamado hellowolrd, ent√£o ele segui a pr√≥xima linha e encontra o que estava buscando e executa a diretiva hellowolrd.</li>
	<li>Essa por sua vez, precisa executar outras duas chamadas main.o e hellowolrd.o, antes de executar seus comandos.</li>
	<li>main.o e helloworld.o n√£o precisam de nenhum pr√©-requisito ent√£o s√≥ executam seus comandos.</li>
	<li>Assim como em fun√ß√µes recursivas (ü§® P√©ssimo exemplo, programador odeia isso! üò¨) depois que a condi√ß√£o de encerramento √© verdadeira, a fun√ß√£o volta de tr√°s para frente executando todo o restante. Ou seja, as condi√ß√µes aqui eram a cria√ß√£o dos arquivos main.o e hellowolrd.o, ent√£o logo volta pro alvo hellowolrd e volta pro alvo all.</li>
</ol>
<br><br><br>	
<b>Macros e Vari√°veis Autom√°ticas</b>
<br>	
	
```
# sintax diretiva makefile (usando macros)
# calma, n√£o sai correndo, beba √°gua, vamos estudar direitinho üòéüòù
	
%.o: %.c %.h
<tab> @$ <$	
	    
# % -> Pega o nome antes do .;

# $@ -> Pega o nome do target(alvo);

# %< -> Pega o primeiro pr√©-requisito;
	
```
	
<br><br>	
<b>Vamos entender um pouco mais sobre o GCC e <a href="https://www.freebsd.org/cgi/man.cgi?query=ar&sektion=1">AR</a>?</b>
<br>
	
```
gcc -c arquivo.c					# -c significa compiler, ou seja, ele vai transformar um arquivo de c√≥digo fonte em um arquivo (.o) arquivo de objeto.
gcc -o <nome arquivo de sa√≠da> arquivos.o 		# -o significa output, mas trata-se do linker, ou seja, ir√° transformar um arquivo (.o) em um arquivo execut√°vel.

gcc arquivo.c						# sem as flags -c e -o, o gcc faz tudo junto, transforma em .o e j√° transforma no execut√°vel padr√£o a.out/a.exe;	

ar rcs <nome_biblioteca.a> <objetos.o...>		# ar -> Junta objetos.o e cria uma biblioteca.a
							# r -> Se a biblioteca j√° existe, substitui os arquivos antigos;
							# c -> Cria se n√£o existe;
							# s -> Cria um indice para as fun√ß√µes da biblioteca, assim o acesso fica mais r√°pido, tipo ID de tabela SQL ao 
							#      invez do nome completo;
```
	
<br>
	
	
	
	
	
	
	
	
	
<h2 id="biblioteca">Que parada √© essa de bibliotecas em C?</h2> 
<br><br><br>
   
<h2 id="restrict">O que √© 'restrict' antes das vari√°veis? √© de comer?</h2>
<b>Que tr√≥√ßo √© Restrict Type Qualifier?</b>
<p>Ele √© usado somente em ponteiros, ele √© uma promessa, diz para o compilador que esse ponteiro √© o √∫nico ponteiro que est√° apontando para o valor apontado, √© o √∫nico caminho par acessar o valor apontado. Como assim J√∫nior? Vamos l√°! Imagina que temos um ponteiro chamado (int* restrict num1) que est√° apontando para o n√∫mero um n√∫mero 10 qualquer, o restrict promete para o compilador que nenhum outro ponteiro est√° apontando para esse mesmo n√∫mero 10. O restrict n√£o afeta nada no c√≥digo em si, mas sim, no modo como o Assembly, ou o compilador executa o c√≥digo, se a promessa do restrict n√£o for respeitada, v√°rios erros podem ser gerados no c√≥digo, por√©m se usado corretamente, pode tornar uma aplica√ß√£o muito mais r√°pida. <br> Bora de exemplo?</p>

```
void updatePtrs(size_t *ptrA, size_t *ptrB, size_t *val)
{
  *ptrA += *val;
  *ptrB += *val;
}
```
	
``` 
; C√≥digo Assembly RISC Machine (hipot√©tico)
ldr r12, [val]     ; Carrega/"Copia" a mem√≥ria alocada apontada por [val] no registrador r12
ldr r3, [ptrA]     ; Carrega/"Copia" a mem√≥ria alocada apontada por [ptrA] no registrador r3
add r3, r3, r12    ; Executa uma soma entre os registradores: r3 = r3 + r12.
str r3, [ptrA]     ; Pega o valor do registrador r3 e joga na mem√≥ria alocada apontada por ptrA.
ldr r3, [ptrB]     ; Espera at√© a opera√ß√£o anterior terminar / Carrega o valor da vari√°vel [ptrB] no registrador r3
ldr r12, [val]     ; Carrega/"Copia" a mem√≥ria alocada apontada por [val] no registrador r12 de novo. Por que?
                   ; porque se o ponteiro val ou ptrA apontarem para o mesmo local, depois da soma feita anteriormente, o valor de val ser√° diferente, ent√£o, o compilador
                   ; precisa ler de novo para garantir que o valor est√° correto.
add r3, r3, r12    ; Executa a soma r3 = r3 + r12
str r3, [ptrB]     ; Pega o valor do registrador r3 e joga na mem√≥ria alocada apontada por ptrA.
``` 
	
<p>O Compilador sem o restrict faz uma verifica√ß√£o pra saber se o valor de val mudou, caso val apontasse para o mesmo bloco de mem√≥ria que os demas ponteiros. </p>
    
    
```
void updatePtrs(size_t *restrict ptrA, size_t *restrict ptrB, size_t *restrict val)
{
  *ptrA += *val;
  *ptrB += *val;
}
```
	
``` 
; C√≥digo Assembly RISC Machine (hipot√©tico)
ldr r12, [val]  ; Aqui o registrador r12 carrega o bloco de mem√≥ria apontado por [val] somente uma vez. Porque o restrict, garante pro compilador que esse ponteiro √© o √∫nico                     ; caminho ou seja, esse valor n√£o vai mudar nas outras opera√ß√µes.
ldr r3, [ptrA]  ; Carrega os blocos de mem√≥ria apontados pelos ponteiros [ptrA] e [ptrB] nos respectivos registradores r3,r4.
ldr r4, [ptrB]
add r3, r3, r12 ; Executa as opera√ß√µes de adi√ß√£o.
add r4, r4, r12
str r3, [ptrA]  ; Executa as opera√ß√µes de atualiza√ß√£o.
str r4, [ptrB]
``` 
	
<p>Agora quando, eu coloco o restrict, o compilador n√£o precisa fazer verifica√ß√µes de consist√™ncia, ele vai direto ao ponto, s√≥ carrega e executa as opera√ß√µes.</p>    
<i>Nesse exemplo simples, pode parecer pouco relevante por√©m, o uso correto do restrict em aplica√ß√µes mais complexos torna a aplica√ß√£o mais r√°pida.</i>
<br><br>

		     
<br><br>
<h2 id="step-by-step">42-libft Passo a Passo</h2><br>
<a href="https://youtu.be/D9G1VOjN_84"><img src="https://img.youtube.com/vi/D9G1VOjN_84/maxresdefault.jpg" width="100%"></a>
<br><br>

<h2 id="outras">Outras coisas legais!</h2>

   
<h4>Trabalhando com Arquivos de cabe√ßalho & #Include Guards</h4>
<p>N√≥s podemos modularizar nossos projetos em C, utilizando arquivos de cabe√ßalho, como assim ? Se n√≥s temos um c√≥digo grande pra fazer, mas queremos separar em arquivos C diferentes, por exemplo na GNL, pr√≥ximo projeto, um arquivo √© para a fun√ß√£o GNL, outro √© para as fun√ß√µes aux√≠liares, para isso podemos trabalhar com arquivos .h, ou arquivos de cabe√ßalho.</p>
   
<b>Por que usamos ifndef?</b>  
<p>Em poucas palavras, essa manobra √© conhecida como Include Guard, basicamente √© impedir que a mesma coisa seja feita mais de uma vez.</p>

```
#ifndef _INCL_GUARD
#define _INCL_GUARD
    /* c√≥digo a ser executado caso _INCL_GUARD ainda n√£o tenha sido criado no programa */
#else
    /* c√≥digo a ser executado caso _INCL_GUARD j√° tenha sido criado, ou seja, sempre deixamos vazio para o programa n√£o adicionar 2x o arquivo.h e bugar o programa. */
#endif    
```
    
    
<b>get_next_line.h</b>
    
```
#ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

/*
 * Aqui v√£o os prot√≥tipos de todas as fun√ß√µes que ser√£o utilizadas no projeto
 * 
 */

#endif
```   
    
<b>get_next_line.c/_utils.c</b>
    
```
#include "get_next_line.h" // inclu√≠ os prot√≥tipos criados no header dentro do projeto.

/*
 * agora podemos criar as fun√ß√µes aqui, e elas podem ser enxergadas por todos os arquivos C que estiverem vinculados com o arquivo.h.
 * isso √© legal para organizar o projeto.
 */

```   
	
<br><br><br><br>

```
int i = 1, j;
j = i++;	
```
<p>i++ √© conhecido como Post Increment('Incrementador Depois'), ou seja, ele s√≥ vai adicionar + 1 ao valor de i, <u>depois que todas as opera√ß√µes da linha terminarem.</u></p>
	
```
int i = 1, j;
j = ++i;	
```
<p>++i √© conhecido como Pre Increment('Incrementador Antes'), ou seja, ele vai adicionar 1 ao valor de i, <u>antes que qualquer opera√ß√£o da linha seja executada.</u></p>
	

<br><br><br><br>
	
```
#include <stdio.h>
#include <string.h>

int main()
{
    char empty[5] = { '\0' };
    char null[5];

    if( strcmp(empty,null)==0 )
        puts("Strings are the same");
    else
        puts("Strings are not the same");

    return(0);
}	
```
<br><br>
```
char *null;
char null2[5];
char *null3 = NULL;
char vazia[5] = {'\0'};

printf("asdf: %s \n", null);
printf("%s \n", null2);
printf("%s \n", null3);
printf("%s \n", vazia);	
```
<br>
<li>String vazia √© uma string que cont√©m 0 caracteres exceto o '\0'.</li>
<li>String Nula √© uma string que foi declarada, tendo alocado mem√≥ria ou n√£o, por√©m n√£o foi inicializada, ou seja, apresenta lixo de mem√≥ria e comportamento inesperado.Quando apontamos uma string para NULL, estamos dizendo que ela est√° apontando para uma posi√ß√£o NULA, s√≥ isso, s√≥ vai impedir ela de pegar MEMORY GARBAGE e pode facilitar o uso de if com essa vari√°vel, mas ela √© NULA e pronto, n√£o aponta para nada!</li><br>
<i>*Pode ser confuso porque algumas fun√ß√µes retornam que uma string √© (null) se n√£o tiver valor dentro dela, mas n√£o confundam, s√£o duas coisas diferentes.</i></p>
<br><br><br><br>	
	

<div>
<h2 id="fontes">Fontes</h2>
<li><a href="https://www.gnu.org/software/make/manual/make.html">Documenta√ß√£o Oficial Makefile</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#Overall-Options">Documenta√ß√£o Oficial GCC -o and -c</a></li>
<li><a href="https://www.embarcados.com.br/introducao-ao-makefile/">Tutorial simples e foda de Makefile</a></li>
<li><a href="https://www.tutorialspoint.com/cprogramming/c_header_files.htm">C Header Files</a></li>
<li><a href="https://en.wikipedia.org/wiki/Include_guard">#Include Guard</a></li>
<li><a href="https://stackoverflow.com/questions/24853/what-is-the-difference-between-i-and-i">Diferen√ßa entre ++i e i++!</a></li>
<li><a href="https://c-for-dummies.com/blog/?p=2641">Diferen√ßa entre NULL e String Vazia</a></li>





</div>
<br><br><br>
<a href="#topo">Voltar ao Topo!</a>
