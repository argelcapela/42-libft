<!--<div id="portfolio-slideshow-items" class="hide-on-portfolio" visibility="0">
    <div class="item"><img src="https://github.com/argelcapela/42-trilha-de-fundamentos/blob/main/assets/libft/125.jpg?raw=true" alt="Avaliação"></div>
    <div class="item"><img src="https://github.com/argelcapela/42-trilha-de-fundamentos/blob/main/assets/libft/libft_test.gif?raw=true" alt="Tripoulle Test"></div>
</div>
-->

<div class="hide-on-portfolio">
<div align="center">
	<img src="https://github.com/argelcapela/argelcapela.rf.gd/blob/main/assets/img/galeria/portfolio_img_42-libft.jpg?raw=true" width="250px">
</div>

## :memo: Descrição:
Esse projeto visa construir do zero uma biblioteca de funções fundamentais para trabalhar com a linguagem C. Por exemplo: substring(), trim(), strdup() etc. Um excelente exercício de lógica, Makefile e construção de bibliotecas.
</div>

<div class="col-12">

## :wrench: Tecnologias utilizadas:<br>
<div style="display: inline_block">
    <img align="center" alt="gel-Js" height="30" width="40" src="https://raw.githubusercontent.com/devicons/devicon/master/icons/c/c-original.svg">

</div>

<div class="col-12">
## :books: Funcionalidades:<br>
<table class="special-border col-12">
<tr>
<th colspan="2">Mandatory</th>
</tr>
<tr>
    <td>Nome</td>
    <td>O que ela faz?</td>
</tr>
<tr>
    <td>isalpha</td>
    <td></td>
</tr>
<tr>
    <td>isdigit</td>
    <td></td>
</tr>
<tr>
    <td>isalnum</td>
    <td></td>
</tr>
<tr>
    <td>isascii</td>
    <td></td>
</tr>
 <tr>
    <td>isprint</td>
    <td></td>
</tr>
<tr>
    <td>strlen</td>
    <td></td>
</tr>
<tr>
    <td>memset</td>
    <td></td>
</tr>
<tr>
    <td>bzero</td>
    <td></td>
</tr>
 <tr>
    <td>memcpy</td>
    <td></td>
</tr>   
<tr>
    <td>memmove</td>
    <td></td>
</tr>    
<tr>
    <td>strlcpy</td>
    <td></td>
</tr>   
<tr>
    <td>strlcat</td>
    <td></td>
</tr>   
<tr>
    <td>toupper</td>
    <td></td>
</tr>   
<tr>
    <td>tolower</td>
    <td></td>
</tr>   
<tr>
    <td>strchr</td>
    <td></td>
</tr>   
<tr>
    <td>strrchr x</td>
    <td>x</td>
</tr>   
<tr>
    <td>strncmp</td>
    <td></td>
</tr>   
 <tr>
    <td>memchr</td>
    <td></td>
</tr>     
<tr>
    <td>memcmp</td>
    <td></td>
</tr>  
<tr>
    <td>strnstr</td>
    <td></td>
</tr>  
<tr>
    <td>atoi</td>
    <td></td>
</tr>  
<tr>
    <td>calloc</td>
    <td></td>
</tr>      
<tr>
    <td>strdup</td>
    <td></td>
</tr>      
<tr>
    <td>ft_substr</td>
    <td></td>
</tr>      
<tr>
    <td>ft_strjoin</td>
    <td></td>
</tr>      
<tr>
    <td>ft_strtrim</td>
    <td></td>
</tr>      
<tr>
    <td>ft_split</td>
    <td></td>
</tr>      
<tr>
    <td>ft_itoa</td>
    <td></td>
</tr>      
<tr>
    <td>ft_strmapi</td>
    <td></td>
</tr>      
<tr>
    <td>ft_striteri</td>
    <td></td>
</tr>      
<tr>
    <td>ft_putchar_fd</td>
    <td></td>
</tr>      
<tr>
    <td>ft_putstr_fd</td>
    <td></td>
</tr>      
<tr>
    <td>ft_putendl_fd</td>
    <td></td>
</tr>      
<tr>
    <td>ft_putnbr_fd</td>
    <td></td>
</tr>           
</table>

<table class="special-border col-12">
<tr>
<th colspan="2">Bonus</th>
</tr>
<tr>
    <td>Nome</td>
    <td>O que ela faz?</td>
</tr>
<tr>
    <td>ft_lstnew</td>
    <td></td>
</tr>
<tr>
    <td>ft_lstadd_front</td>
    <td></td>
</tr>
<tr>
    <td>ft_lstsize</td>
    <td></td>
</tr> 
<tr>
    <td>ft_lstlast</td>
    <td></td>
</tr>   
<tr>
    <td>ft_lstadd_back</td>
    <td></td>
</tr> 
<tr>
    <td>ft_lstdelone</td>
    <td></td>
</tr> 
<tr>
    <td>ft_lstclear</td>
    <td></td>
</tr> 
<tr>
    <td>ft_lstiter</td>
    <td></td>
</tr> 
<tr>
    <td>ft_lstmap</td>
    <td></td>
</tr> 
</table>
    
</div>

<div class="col-12">

## :rocket: Rodando o projeto:<br>
    
<li>Link Github: <a href="https://github.com/argelcapela/42_libft">Link</a></li>
<li>Link 42 Page: <a href="#">Link</a></li>
 
</div>
<div class="col-12">

## :soon: Implementação futura:<br>
    
<li>Nada em mente por enquanto.</li>
    
</div>
<div class="col-12">
    

## :handshake: Colaboradores:<br>
<table>
  <tr>
    <td align="center">
      <a href="http://github.com/argelcapela">
        <img src="https://avatars.githubusercontent.com/u/79276276?s=400&u=055b803f4708d59eaf50208ba601f85844125757&v=4" width="100px;" alt="Foto de Argel Capela!"/><br>
        <sub>
          <b>Argel Capela</b>
        </sub>
      </a>
    </td>
  </tr>
</table>
</div>
<div class="col-12">
    
## :dart: Status do projeto:<br>

<li>Entregue com pontuação 120%.</li>
    
</div>
    
<li><a href="#restrict">Restrict</a></li>
    
<h1>Trabalhando com Arquivos de cabeçalho & #Include Guards</h1>
<p>Nós podemos modularizar nossos projetos em C, utilizando arquivos de cabeçalho, como assim ? Se nós temos um código grande pra fazer, mas queremos separar em arquivos C diferentes, por exemplo na GNL, próximo projeto, um arquivo é para a função GNL, outro é para as funções auxíliares, para isso podemos trabalhar com arquivos .h, ou arquivos de cabeçalho.</p>
   
<b>Por que usamos ifndef?</b>  
<p>Em poucas palavras, essa manobra é conhecida como Include Guard, basicamente é impedir que a mesma coisa seja feita mais de uma vez.</p>

```
#ifndef _INCL_GUARD
#define _INCL_GUARD
    /* código a ser executado caso _INCL_GUARD ainda não tenha sido criado no programa */
#else
    /* código a ser executado caso _INCL_GUARD já tenha sido criado, ou seja, sempre deixamos vazio para o programa não adicionar 2x o arquivo.h e bugar o programa. */
#endif    
```
    
    
<b>get_next_line.h</b>
    
```
#ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

/*
 * Aqui vão os protótipos de todas as funções que serão utilizadas no projeto
 * 
 */

#endif
```   
    
<b>get_next_line.c/_utils.c</b>
    
```
#include "get_next_line.h" // incluí os protótipos criados no header dentro do projeto.

/*
 * agora podemos criar as funções aqui, e elas podem ser enxergadas por todos os arquivos C que estiverem vinculados com o arquivo.h.
 * isso é legal para organizar o projeto.
 */

```   
    
<h2>Makefile</h2>
<h2>Criando Bibliotecas em C</h2>
   
<h2 id="restrict">Restrict Type Qualifier</h2>
<b>O que é esse tróço?</b>
<p>Ele é usado somente em ponteiros, ele é uma promessa, diz para o compilador que esse ponteiro é o único ponteiro que está apontando para o valor apontado, é o único caminho par acessar o valor apontado. Como assim Júnior? Vamos lá! Imagina que temos um ponteiro chamado (int* restrict num1) que está apontando para o número um número 10 qualquer, o restrict promete para o compilador que nenhum outro ponteiro está apontando para esse mesmo número 10. O restrict não afeta nada no código em si, mas sim, no modo como o Assembly, ou o compilador executa o código, se a promessa do restrict não for respeitada, vários erros podem ser gerados no código, porém se usado corretamente, pode tornar uma aplicação muito mais rápida. <br> Bora de exemplo?</p>

```
void updatePtrs(size_t *ptrA, size_t *ptrB, size_t *val)
{
  *ptrA += *val;
  *ptrB += *val;
}
```
``` 
; Código Assembly RISC Machine (hipotético)
ldr r12, [val]     ; Carrega/"Copia" a memória alocada apontada por [val] no registrador r12
ldr r3, [ptrA]     ; Carrega/"Copia" a memória alocada apontada por [ptrA] no registrador r3
add r3, r3, r12    ; Executa uma soma entre os registradores: r3 = r3 + r12.
str r3, [ptrA]     ; Pega o valor do registrador r3 e joga na memória alocada apontada por ptrA.
ldr r3, [ptrB]     ; Espera até a operação anterior terminar / Carrega o valor da variável [ptrB] no registrador r3
ldr r12, [val]     ; Carrega/"Copia" a memória alocada apontada por [val] no registrador r12 de novo. Por que?
                   ; porque se o ponteiro val ou ptrA apontarem para o mesmo local, depois da soma feita anteriormente, o valor de val será diferente, então, o compilador
                   ; precisa ler de novo para garantir que o valor está correto.
add r3, r3, r12    ; Executa a soma r3 = r3 + r12
str r3, [ptrB]     ; Pega o valor do registrador r3 e joga na memória alocada apontada por ptrA.
``` 
<p>O Compilador sem o restrict faz uma verificação pra saber se o valor de val mudou, caso val apontasse para o mesmo bloco de memória que os demas ponteiros. </p>
    
    
```
void updatePtrs(size_t *restrict ptrA, size_t *restrict ptrB, size_t *restrict val)
{
  *ptrA += *val;
  *ptrB += *val;
}
```
``` 
; Código Assembly RISC Machine (hipotético)
ldr r12, [val]  ; Aqui o registrador r12 carrega o bloco de memória apontado por [val] somente uma vez. Porque o restrict, garante pro compilador que esse ponteiro é o único                     ; caminho ou seja, esse valor não vai mudar nas outras operações.
ldr r3, [ptrA]  ; Carrega os blocos de memória apontados pelos ponteiros [ptrA] e [ptrB] nos respectivos registradores r3,r4.
ldr r4, [ptrB]
add r3, r3, r12 ; Executa as operações de adição.
add r4, r4, r12
str r3, [ptrA]  ; Executa as operações de atualização.
str r4, [ptrB]
``` 
<p>Agora quando, eu coloco o restrict, o compilador não precisa fazer verificações de consistência, ele vai direto ao ponto, só carrega e executa as operações.</p>    
<i>Nesse exemplo simples, pode parecer pouco relevante porém, o uso correto do restrict em aplicações mais complexos torna a aplicação mais rápida.</i>
<br><br>

<a href="https://en.wikipedia.org/wiki/Include_guard">#Include Guard</a>
    
    
